#!/bin/bash

# =======================================================================
# Kubernetes Secret Generator from .env files
# =======================================================================
# This script generates Kubernetes secrets from environment files
# 
# Single File Mode (preferred):
#   - Uses .env file if it exists
#   - Simpler workflow for single-environment setups
#
# Multi-File Mode (advanced):
#   - Uses .env.[environment] files
#   - Supports multiple environments
#
# Usage: ./scripts/generate-secrets.sh [environment] [namespace]
#   environment: development|staging|production (default: development)
#   namespace: kubernetes namespace (default: api-deployment-demo)

set -euo pipefail

# Default values
ENVIRONMENT="${1:-all}"
NAMESPACE="${2:-api-deployment-demo}"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

# Check if we should process all environments
PROCESS_ALL=false
if [[ "$ENVIRONMENT" == "all" ]] && [[ -f "$PROJECT_ROOT/.env" ]] && grep -q "^STG_\|^PROD_" "$PROJECT_ROOT/.env"; then
    PROCESS_ALL=true
fi

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Helper functions
log_info() {
    echo -e "${BLUE}‚ÑπÔ∏è  $1${NC}"
}

log_success() {
    echo -e "${GREEN}‚úÖ $1${NC}"
}

log_warning() {
    echo -e "${YELLOW}‚ö†Ô∏è  $1${NC}"
}

log_error() {
    echo -e "${RED}‚ùå $1${NC}"
}

# Function to update or add environment variables in .env files
update_env_file() {
    local env_file="$1"
    local var_name="$2"
    local var_value="$3"
    
    # Determine if we're using prefixed variables (STG_/PROD_)
    local prefix=""
    if grep -q "^ENVIRONMENT=" "$env_file"; then
        local env_setting
        env_setting=$(grep "^ENVIRONMENT=" "$env_file" | cut -d'=' -f2 | tr -d ' ')
        case "$env_setting" in
            staging)
                prefix="STG_"
                ;;
            production)
                prefix="PROD_"
                ;;
        esac
    fi
    
    # If we have a prefix, update both the prefixed and unprefixed versions
    local vars_to_update=("$var_name")
    if [[ -n "$prefix" ]]; then
        vars_to_update=("${prefix}${var_name}" "$var_name")
    fi
    
    # Create backup
    cp "$env_file" "${env_file}.backup.$(date +%s)"
    
    local updated=false
    for target_var in "${vars_to_update[@]}"; do
        # Check if variable already exists
        if grep -q "^${target_var}=" "$env_file"; then
            # Update existing variable using a different approach to avoid sed issues
            # Create temp file with updated content
            local temp_file="${env_file}.tmp.$$"
            while IFS= read -r line; do
                if [[ $line =~ ^${target_var}= ]]; then
                    # Special handling for DATABASE_URL to preserve the full URL structure
                    if [[ "$var_name" == "DATABASE_URL" ]]; then
                        echo "${target_var}=${var_value}"
                    else
                        echo "${target_var}=${var_value}"
                    fi
                    updated=true
                else
                    echo "$line"
                fi
            done < "$env_file" > "$temp_file"
            mv "$temp_file" "$env_file"
            if [[ "$updated" == true ]]; then
                log_info "Updated existing ${target_var} in ${env_file}"
            fi
        elif grep -q "^# ${target_var}=" "$env_file"; then
            # Uncomment and update commented variable
            local temp_file="${env_file}.tmp.$$"
            while IFS= read -r line; do
                if [[ $line =~ ^#\ ${target_var}= ]]; then
                    echo "${target_var}=${var_value}"
                    updated=true
                else
                    echo "$line"
                fi
            done < "$env_file" > "$temp_file"
            mv "$temp_file" "$env_file"
            if [[ "$updated" == true ]]; then
                log_info "Uncommented and updated ${target_var} in ${env_file}"
            fi
        fi
    done
    
    # Only add to end if no existing variable was found
    if [[ "$updated" == false ]]; then
        echo "" >> "$env_file"
        echo "# Generated by generate-secrets.sh on $(date)" >> "$env_file"
        echo "${var_name}=${var_value}" >> "$env_file"
        log_info "Added new ${var_name} to ${env_file}"
    fi
}

# Determine and validate environment file
get_env_file() {
    # Check for environment-specific .env file first
    if [[ -f "$PROJECT_ROOT/.env.$ENVIRONMENT" ]]; then
        echo "$PROJECT_ROOT/.env.$ENVIRONMENT"
        return 0
    fi
    
    # Fall back to .env file (single file mode)
    if [[ -f "$PROJECT_ROOT/.env" ]]; then
        echo "$PROJECT_ROOT/.env"
        return 0
    fi
    
    # If no files exist, try environment-specific as last resort
    echo "$PROJECT_ROOT/.env.$ENVIRONMENT"
}

# Validate environment
validate_environment() {
    env_file=$(get_env_file)
    
    if [[ ! -f "$env_file" ]]; then
        log_error "Environment file not found: $env_file"
        log_info ""
        log_info "Available options:"
        if [[ -f "$PROJECT_ROOT/.env.example" ]]; then
            log_info "üìã Copy example file to create needed file:"
            if [[ "$env_file" == "$PROJECT_ROOT/.env" ]]; then
                log_info "  cp .env.example .env"
            else
                log_info "  cp .env.example $(basename "$env_file")"
            fi
        fi
        ls -1 "$PROJECT_ROOT"/.env.* 2>/dev/null | sed 's/.*\.env\./  - .env./' || echo "  No .env files found"
        log_info ""
        exit 1
    fi
    
    log_info "Using .env file: $env_file"
    
    # Check for placeholder values that need replacement
    if grep -q "REPLACE_WITH_.*_PASSWORD\|REPLACE_WITH_.*_SECRET" "$env_file"; then
        log_info "Found placeholder values in $env_file that will be replaced with secure values"
    fi
    
    # Empty values and null values are fine - they'll be auto-generated
    log_info "Empty values will be auto-generated with secure passwords"
}

# Check for placeholder values
check_placeholders() {
    local env_file
    env_file=$(get_env_file)
    
    if grep -q "REPLACE_WITH_" "$env_file"; then
        log_info "Found placeholder values in $env_file that will be auto-generated:"
        grep "REPLACE_WITH_" "$env_file" | sed 's/^/    /'
    fi
}

# Load environment variables
load_env() {
    local env_file
    
    # Get the correct env file
    env_file=$(get_env_file)
    
    log_info "Loading environment variables from $env_file"
    
    # Use load-env-vars.sh if it exists to handle prefixed variables
    if [[ -f "$SCRIPT_DIR/load-env-vars.sh" ]]; then
        # Export variables from load-env-vars.sh (handles STG_/PROD_ prefixes)
        set -a
        eval "$($SCRIPT_DIR/load-env-vars.sh)"
        set +a
    else
        # Fallback: Export variables while preserving existing environment
        set -a
        # shellcheck source=/dev/null
        source "$env_file"
        set +a
    fi
    
    # Set defaults for optional variables that might be commented out
    CORS_ORIGINS="${CORS_ORIGINS:-*}"
    ALLOWED_HOSTS="${ALLOWED_HOSTS:-localhost,127.0.0.1}"
    GRAFANA_ADMIN_USER="${GRAFANA_ADMIN_USER:-admin}"
    
    # Generate secure passwords for insecure defaults
    passwords_generated=false
    
    # Check and generate DB_PASSWORD if insecure or placeholder
    if [[ "${DB_PASSWORD:-}" == "insecure_db_password" ]] || [[ "${DB_PASSWORD:-}" =~ (REPLACE_WITH|CHANGE_ME).*PASSWORD ]] || [[ -z "${DB_PASSWORD:-}" ]]; then
        DB_PASSWORD=$(openssl rand -base64 24)
        update_env_file "$env_file" "DB_PASSWORD" "$DB_PASSWORD"
        echo "‚ÑπÔ∏è  Generated secure database password"
        passwords_generated=true
        
        # Update DATABASE_URL with new password
        if [[ -n "${DATABASE_URL:-}" ]]; then
            # Extract components and rebuild URL with new password
            DB_NAME_FROM_URL=$(echo "$DATABASE_URL" | sed -n 's/.*\/\([^?]*\).*/\1/p')
            NEW_DATABASE_URL="postgresql://${DB_USER}:${DB_PASSWORD}@${DB_HOST}:${DB_PORT}/${DB_NAME_FROM_URL:-$DB_NAME}"
            update_env_file "$env_file" "DATABASE_URL" "$NEW_DATABASE_URL"
            echo "‚ÑπÔ∏è  Updated DATABASE_URL with new password"
        fi
    fi
    
    # Check and generate SECRET_KEY if insecure or placeholder
    if [[ "${SECRET_KEY:-}" == "insecure_secret_key" ]] || [[ "${SECRET_KEY:-}" =~ (REPLACE_WITH|CHANGE_ME).*SECRET ]] || [[ -z "${SECRET_KEY:-}" ]]; then
        SECRET_KEY=$(openssl rand -base64 32)
        update_env_file "$env_file" "SECRET_KEY" "$SECRET_KEY"
        echo "‚ÑπÔ∏è  Generated secure API secret key"
        passwords_generated=true
    fi
    
    # Generate secure Grafana password if not provided or placeholder
    if [[ -z "${GRAFANA_ADMIN_PASSWORD:-}" ]] || [[ "${GRAFANA_ADMIN_PASSWORD:-}" =~ (REPLACE_WITH|CHANGE_ME).*PASSWORD ]]; then
        GRAFANA_ADMIN_PASSWORD=$(openssl rand -base64 16)
        update_env_file "$env_file" "GRAFANA_ADMIN_PASSWORD" "$GRAFANA_ADMIN_PASSWORD"
        echo "‚ÑπÔ∏è  Generated secure Grafana admin password"
        passwords_generated=true
    fi
    
    # Also ensure GRAFANA_ADMIN_USER is set
    if [ -z "${GRAFANA_ADMIN_USER:-}" ]; then
        update_env_file "$env_file" "GRAFANA_ADMIN_USER" "$GRAFANA_ADMIN_USER"
        echo "‚ÑπÔ∏è  Added Grafana admin user to .env file"
    fi
    
    if [ "$passwords_generated" = true ]; then
        echo "üíæ Updated $env_file with generated secure passwords"
        echo "üí° All passwords saved to .env file for reuse"
        echo "üîê Please backup your .env file securely!"
    fi
    
    # Set defaults for ConfigMap variables
    DB_HOST="${DB_HOST:-postgres}"
    DB_PORT="${DB_PORT:-5432}"
    DB_HOST_AUTH_METHOD="${DB_HOST_AUTH_METHOD:-md5}"
    API_WORKERS="${API_WORKERS:-4}"
    API_PORT="${API_PORT:-8000}"
    SERVER_NAME="${SERVER_NAME:-localhost}"
    HTTP_PORT="${HTTP_PORT:-80}"
    HTTPS_PORT="${HTTPS_PORT:-443}"
    PROMETHEUS_RETENTION="${PROMETHEUS_RETENTION:-30d}"
    POSTGRES_DATA_PATH="${POSTGRES_DATA_PATH:-/var/lib/postgresql/data}"
    PROMETHEUS_DATA_PATH="${PROMETHEUS_DATA_PATH:-/prometheus}"
}

# Generate API secrets
generate_api_secrets() {
    local output_file="$PROJECT_ROOT/kubernetes/secrets-$ENVIRONMENT.yaml"
    local source_file
    
    # Determine source file name for documentation
    if [[ -f "$PROJECT_ROOT/.env" ]]; then
        source_file=".env"
    else
        source_file=".env.$ENVIRONMENT"
    fi
    
    log_info "Generating API secrets for $ENVIRONMENT environment"
    
    cat > "$output_file" << EOF
# =======================================================================
# Auto-generated Kubernetes Secrets for $ENVIRONMENT environment
# Generated on: $(date)
# Source: $source_file
# =======================================================================
# ‚ö†Ô∏è  This file contains sensitive data - handle according to your security policy
# üîê For production: Use external secret management (Vault, AWS Secrets Manager, etc.)

apiVersion: v1
kind: Secret
metadata:
  name: api-secrets
  namespace: $NAMESPACE
  labels:
    app: api-demo
    environment: $ENVIRONMENT
    generated-by: generate-secrets.sh
  annotations:
    generated-at: "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
    source-file: "$source_file"
type: Opaque
stringData:
  SECRET_KEY: "$SECRET_KEY"
  DB_PASSWORD: "$DB_PASSWORD"
  DATABASE_URL: "$DATABASE_URL"
  API_ENV: "$API_ENV"
  DEBUG: "$DEBUG"
  LOG_LEVEL: "$LOG_LEVEL"
  CORS_ORIGINS: "$CORS_ORIGINS"
  ALLOWED_HOSTS: "$ALLOWED_HOSTS"

---
apiVersion: v1
kind: Secret
metadata:
  name: postgres-secrets
  namespace: $NAMESPACE
  labels:
    app: api-demo
    component: database
    environment: $ENVIRONMENT
    generated-by: generate-secrets.sh
  annotations:
    generated-at: "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
    source-file: "$source_file"
type: Opaque
stringData:
  DB_PASSWORD: "$DB_PASSWORD"
  DB_NAME: "$DB_NAME"
  DB_USER: "$DB_USER"

---
apiVersion: v1
kind: Secret
metadata:
  name: grafana-admin-secret
  namespace: monitoring
  labels:
    app: grafana
    component: monitoring
    environment: $ENVIRONMENT
    generated-by: generate-secrets.sh
  annotations:
    generated-at: "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
    source-file: "$source_file"
type: Opaque
stringData:
  admin-password: "$GRAFANA_ADMIN_PASSWORD"
  admin-user: "$GRAFANA_ADMIN_USER"
EOF

    log_success "Generated secrets file: $output_file"
}

# Generate ConfigMap for non-sensitive environment variables
generate_configmap() {
    local output_file="$PROJECT_ROOT/kubernetes/configmap-$ENVIRONMENT.yaml"
    local source_file
    
    # Determine source file name for documentation
    if [[ -f "$PROJECT_ROOT/.env" ]]; then
        source_file=".env"
    else
        source_file=".env.$ENVIRONMENT"
    fi
    
    log_info "Generating ConfigMap for $ENVIRONMENT environment"
    
    cat > "$output_file" << EOF
# =======================================================================
# Auto-generated Kubernetes ConfigMap for $ENVIRONMENT environment
# Generated on: $(date)
# Source: $source_file
# =======================================================================
# üìù This file contains non-sensitive configuration data

apiVersion: v1
kind: ConfigMap
metadata:
  name: api-config
  namespace: $NAMESPACE
  labels:
    app: api-demo
    environment: $ENVIRONMENT
    generated-by: generate-secrets.sh
  annotations:
    generated-at: "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
    source-file: "$source_file"
data:
  DB_NAME: "$DB_NAME"
  DB_USER: "$DB_USER"
  DB_HOST: "$DB_HOST"
  DB_PORT: "$DB_PORT"
  DB_HOST_AUTH_METHOD: "$DB_HOST_AUTH_METHOD"
  API_ENV: "$API_ENV"
  API_WORKERS: "$API_WORKERS"
  API_PORT: "$API_PORT"
  SERVER_NAME: "$SERVER_NAME"
  HTTP_PORT: "$HTTP_PORT"
  HTTPS_PORT: "$HTTPS_PORT"
  PROMETHEUS_RETENTION: "$PROMETHEUS_RETENTION"
  POSTGRES_DATA_PATH: "$POSTGRES_DATA_PATH"
  PROMETHEUS_DATA_PATH: "$PROMETHEUS_DATA_PATH"
EOF

    # Add production-specific config if available
    if [[ -n "${REPLICA_COUNT:-}" ]]; then
        cat >> "$output_file" << EOF
  REPLICA_COUNT: "$REPLICA_COUNT"
  MAX_REPLICAS: "$MAX_REPLICAS"
  CPU_LIMIT: "$CPU_LIMIT"
  MEMORY_LIMIT: "$MEMORY_LIMIT"
EOF
    fi

    log_success "Generated ConfigMap file: $output_file"
}

# Apply secrets to cluster
apply_secrets() {
    local secrets_file="$PROJECT_ROOT/kubernetes/secrets-$ENVIRONMENT.yaml"
    
    if [[ "${APPLY:-false}" == "true" ]]; then
        log_info "Applying secrets to Kubernetes cluster"
        
        # Create namespace if it doesn't exist
        kubectl create namespace "$NAMESPACE" --dry-run=client -o yaml | kubectl apply -f -
        kubectl create namespace monitoring --dry-run=client -o yaml | kubectl apply -f -
        
        # Note: Using static configmaps.yaml instead of generated configmap
        log_info "Using static ConfigMap from kubernetes/configmaps.yaml"
        
        # Apply secrets
        kubectl apply -f "$secrets_file"
        log_success "Applied secrets to cluster"
        
        # Verify secrets
        log_info "Verifying secrets in cluster:"
        kubectl get secrets -n "$NAMESPACE" -l "generated-by=generate-secrets.sh"
        kubectl get secrets -n monitoring -l "generated-by=generate-secrets.sh"
    else
        log_info "Files generated. To apply to cluster, run:"
        log_info "  kubectl apply -f $secrets_file"
        log_info "Or run this script with APPLY=true"
    fi
}

# Show usage
show_usage() {
    echo "Usage: $0 [environment] [namespace]"
    echo ""
    echo "üîß Recommended Workflow:"
    echo "  1. cp .env.example .env     # Copy template"
    echo "  2. nano .env                # Edit with actual values"
    echo "  3. $0                       # Generate secrets"
    echo "  4. APPLY=true $0            # Apply to cluster"
    echo ""
    echo "File Modes:"
    echo "  Single File Mode: Uses .env (recommended for simple setups)"
    echo "  Multi-File Mode:  Uses .env.[environment] files"
    echo ""
    echo "Arguments:"
    echo "  environment    Environment name (staging, production, all, or development)"
    echo "                 'all' - Process both staging and production (unified .env)"
    echo "  namespace      Kubernetes namespace (default: api-deployment-demo)"
    echo ""
    echo "Environment variables:"
    echo "  APPLY=true     Automatically apply secrets to cluster"
    echo ""
    echo "Examples:"
    echo "  $0              # Process all environments (staging + production)"
    echo "  $0 staging      # Process staging only"
    echo "  $0 production   # Process production only"
    echo "  $0 development  # Uses .env or .env.development"
    echo "  APPLY=true $0   # Generate and apply all to cluster"
    echo ""
    echo "Available files:"
    if [[ -f "$PROJECT_ROOT/.env" ]]; then
        echo "  ‚úÖ .env (ready to use)"
    elif [[ -f "$PROJECT_ROOT/.env.example" ]]; then
        echo "  üìã .env.example (copy to .env first)"
    fi
    
    # List other .env files (excluding .env.example)
    for file in "$PROJECT_ROOT"/.env.*; do
        if [[ -f "$file" && "$file" != *".env.example" ]]; then
            basename "$file" | sed 's/^/  - /'
        fi
    done
}

# Main function
main() {
    log_info "üîê Kubernetes Secret Generator"
    
    # Handle "all" option to process both staging and production
    if [[ "$PROCESS_ALL" == true ]]; then
        log_info "Processing all environments (staging + production)"
        echo ""
        
        local env_file="$PROJECT_ROOT/.env"
        local original_env
        original_env=$(grep "^ENVIRONMENT=" "$env_file" | cut -d'=' -f2 | tr -d ' ')
        
        # Process staging
        log_info "üîπ Processing STAGING environment"
        ENVIRONMENT="staging"
        # Temporarily set ENVIRONMENT in .env for load-env-vars.sh
        sed -i.bak 's/^ENVIRONMENT=.*/ENVIRONMENT=staging/' "$env_file" && rm -f "$env_file.bak"
        log_info "Namespace: $NAMESPACE"
        echo ""
        validate_environment
        check_placeholders  
        load_env
        generate_api_secrets
        apply_secrets
        
        echo ""
        echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
        echo ""
        
        # Process production
        log_info "üî∏ Processing PRODUCTION environment"
        ENVIRONMENT="production"
        # Temporarily set ENVIRONMENT in .env for load-env-vars.sh
        sed -i.bak 's/^ENVIRONMENT=.*/ENVIRONMENT=production/' "$env_file" && rm -f "$env_file.bak"
        log_info "Namespace: $NAMESPACE"
        echo ""
        validate_environment
        check_placeholders
        load_env
        generate_api_secrets
        apply_secrets
        
        # Restore original ENVIRONMENT setting
        sed -i.bak "s/^ENVIRONMENT=.*/ENVIRONMENT=$original_env/" "$env_file" && rm -f "$env_file.bak"
        
        echo ""
        log_success "All environments processed successfully!"
        log_warning "Security reminders:"
        log_warning "1. Review generated files before committing"
        log_warning "2. Consider using external secret management"
        log_warning "3. Rotate secrets regularly"
        log_warning "4. Audit secret access logs"
        return 0
    fi
    
    # Single environment processing
    log_info "Environment: $ENVIRONMENT"
    log_info "Namespace: $NAMESPACE"
    echo ""
    
    if [[ "$ENVIRONMENT" == "--help" || "$ENVIRONMENT" == "-h" ]]; then
        show_usage
        exit 0
    fi
    
    validate_environment
    check_placeholders
    load_env
    generate_api_secrets
    # Note: ConfigMap generation skipped - using static kubernetes/configmaps.yaml instead
    # generate_configmap
    apply_secrets
    
    echo ""
    log_success "Secret generation complete!"
    
    if [[ "$ENVIRONMENT" != "development" ]]; then
        echo ""
        log_warning "Security reminders for $ENVIRONMENT:"
        log_warning "1. Review generated files before committing"
        log_warning "2. Consider using external secret management"
        log_warning "3. Rotate secrets regularly"
        log_warning "4. Audit secret access logs"
    fi
}

# Run main function
main "$@"